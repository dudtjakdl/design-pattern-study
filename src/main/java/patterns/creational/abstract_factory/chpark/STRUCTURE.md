# 추상 팩토리 패턴 구조도

## 추상 팩토리 패턴의 핵심

### 관계도

```
클라이언트 (AbstractFactoryExample)
    │
    │ uses
    ▼
┌─────────────────┐
│   CarFactory    │  ← 추상 팩토리 인터페이스
│   (인터페이스)   │
└────────┬────────┘
         │
         │ implements
         │
    ┌────┴────┐
    │         │
    ▼         ▼
┌─────────┐ ┌─────────┐      ... (7개 팩토리)
│Hyundai  │ │  Kia    │
│Factory  │ │Factory  │
└────┬────┘ └────┬────┘
     │           │
     │ creates   │ creates
     │           │
     ▼           ▼
┌─────────┐ ┌─────────┐
│Hyundai  │ │  Kia    │
│Vehicle  │ │Vehicle  │
│Info     │ │Info     │
└─────────┘ └─────────┘
     │           │
     │           │
     ▼           ▼
┌─────────┐ ┌─────────┐
│Hyundai  │ │  Kia    │
│Engine   │ │Engine   │
└─────────┘ └─────────┘
```

## 추상 팩토리 패턴 적용 포인트

1. **추상 팩토리 (CarFactory)**
   - 관련된 여러 제품 객체들의 집합을 생성하는 인터페이스 제공
   - `createVehicleInfo()`와 `createEngine()` 메서드로 관련 객체들을 함께 생성

2. **구체적인 팩토리들 (7개 브랜드 Factory)**
   - 각 브랜드별로 일관된 제품 집합을 생성
   - 예: `HyundaiCarFactory`는 항상 `HyundaiVehicleInfo`와 `HyundaiEngine`을 함께 생성

3. **추상 제품들 (VehicleInfo, Engine)**
   - 각 제품군의 공통 인터페이스 정의
   - 클라이언트는 추상 제품 타입만 사용

4. **구체적인 제품들 (각 브랜드별 구현체)**
   - 추상 제품의 구체적인 구현
   - 각 브랜드별 고유한 특성을 가짐

## 추상 팩토리 패턴의 장점

**일관성 보장**: 하나의 팩토리가 관련된 객체들을 함께 생성하므로 호환성 보장
**느슨한 결합**: 클라이언트는 구체적인 클래스가 아닌 추상 인터페이스에 의존
**확장성**: 새로운 브랜드 추가 시 팩토리와 제품 구현체만 추가하면 됨
**단일 책임**: 각 팩토리는 특정 브랜드의 제품 생성에만 책임

