# 싱글톤 패턴

## 구현방법 1
1. 생성자를 private으로 만든 이유?
   - 외부에서 임의로 인스턴스를 생성하지 못하도록 하여 단 하나의 인스턴스만 유지하기 위해서입니다. 생성 경로를 `getInstance()`로 강제합니다.
2. getInstance() 메소드를 static으로 선언한 이유?
   - 인스턴스가 아직 없을 때도 접근 가능해야 하므로 클래스 레벨에서 호출할 수 있도록 `static`으로 제공합니다.
3. getInstance()가 멀티쓰레드 환경에서 안전하지 않은 이유?
   - 여러 스레드가 동시에 `instance == null`을 통과하면 각각 생성하여 다중 인스턴스가 생길 수 있는 경쟁 상태가 발생합니다.


## 구현방법 2
1. 자바의 동기화 블럭 처리 방법은?
   - `synchronized` 키워드를 메소드 또는 블록에 사용하여 모니터 락으로 임계영역을 보호합니다.
2. getInstance() 메소드 동기화시 사용하는 락(lock)은 인스턴스의 락인가 클래스의 락인가? 그 이유는?
   - `getInstance()`가 `static`이므로 클래스 초기화 상태를 보호해야 하며, 따라서 클래스 락(예: `synchronized(Singleton.class)`)이 사용됩니다.

## 구현방법 3
1. 이른 초기화가 단점이 될 수도 있는 이유?
   - 사용하지 않아도 인스턴스를 만들므로 메모리/초기화 비용 낭비, 클래스 로딩 순서에 따른 부작용, 예외 처리 곤란 등의 단점이 있습니다.
2. 만약에 생성자에서 checked 예외를 던진다면
   이 코드를 어떻게 변경해야 할까요?
   - 정적 초기화로는 checked 예외를 던질 수 없습니다. 해결책은 (a) 팩토리 메소드가 `throws`를 선언하고 내부에서 지연 초기화로 생성하거나, (b) 초기화 시 발생 예외를 래핑하여 언체크 예외로 전환하는 방식입니다. 실무에선 지연 초기화(Holder/DCL)로 전환합니다.

## 구현방법 4
1. double check locking이라고 부르는 이유?
   - 동기화 전 한 번, 동기화 블록 내부에서 한 번 총 두 번 `null`을 확인하기 때문에 그렇습니다.
2. instacne 변수는 어떻게 정의해야 하는가? 그 이유는?
   - 인스턴스 필드는 `volatile`로 선언해야 합니다. 객체 생성 시 명령 재배치로 초기화 전 참조가 노출되는 것을 막고 가시성을 보장합니다.

## 구현방법 5
1. 이 방법은 static final를 썼는데도 왜 지연 초기화
   (lazy initialization)라고 볼 수 있는가?
   - 내부 정적 클래스가 처음 참조될 때까지 로드되지 않으므로, 필드가 `static final`이어도 클래스 로딩 시점이 지연되어 결과적으로 지연 초기화가 됩니다.

## 싱글톤 패턴 구현 깨트리는 방법
1. 리플렉션에 대해 설명하세요.
   - 런타임에 클래스/필드/메소드/생성자를 검사·접근·호출하는 메커니즘입니다.
2. setAccessible(true)를 사용하는 이유는?
   - `setAccessible(true)`로 접근 제어를 무시하여 `private` 생성자에도 접근하기 위해 사용합니다.
3. 자바의 직렬화 & 역직렬화에 대해 설명하세요.
   - 직렬화/역직렬화: 객체를 바이트 스트림(byte-stream)으로 변환/복원하는 과정으로, 역직렬화 시 새로운 인스턴스가 생성되어 싱글톤이 깨질 수 있습니다.
4. SerializableId란 무엇이며 왜 쓰는가?
   - `serialVersionUID`: 직렬화 호환성을 위한 클래스 버전 식별자입니다. 클래스 변경 시 버전 불일치를 방지하거나 의도적으로 실패시키는 데 사용됩니다.

## 구현방법 6
1. enum 타입의 인스턴스를 리팩토링을 만들 수 있는가?
   - 리플렉션(Reflection)으로 새 인스턴스를 만들 수 없습니다. 자바는 enum의 추가 인스턴스 생성을 금지합니다.
2. enum으로 싱글톤 타입을 구현할 때의 단점은?
   - 지연 초기화 시 파라미터 주입이 어렵고, 상속을 사용할 수 없으며, DI/테스팅에서 대체 구현 주입이 불편할 수 있습니다.
3. 직렬화 & 역직렬화 시에 별도로 구현해야 하는 메소드가 있는가?
   - 별도 메소드가 필요 없습니다. enum은 직렬화 안정성을 언어 차원에서 보장합니다(`readResolve` 불필요).

## 복습
1. 자바에서 enum을 사용하지 않고 싱글톤 패턴을 구현하는 방법은?
   - Eager 초기화, 메소드 전체 동기화, DCL(+`volatile`), Initialization-on-demand holder.
2. private 생성자와 static 메소드를 사용하는 방법의 단점은?
   - 단점: 전역 상태로 결합 증가, 테스트/모킹 어려움, 생명주기/리소스 관리 난해, 리플렉션/직렬화 공격 가능성, 동기화 비용(지연 초기화 시).
3. enum을 사용해 싱글톤 패턴을 구현하는 방법의 장점과 단점은?
   - 장점: 구현 간단, 직렬화/리플렉션에 안전, 스레드 안전 보장. 
   - 단점: 유연성 낮음(상속/파라미터화/지연 주입 어려움), 일부 프레임워크와의 적합성 이슈.
4. static inner 클래스를 사용해 싱글톤 패턴을 구현하라.
   ```java
   public class Singleton {
       private Singleton() {}
   
       private static class Holder {
           private static final Singleton INSTANCE = new Singleton();
       }
   
       public static Singleton getInstance() {
           return Holder.INSTANCE;
       }
   }
   ```